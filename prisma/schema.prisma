generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model CaseImage {
  id        String   @id
  caseId    String
  url       String
  alt       String
  caption   String?
  order     Int      @default(0)
  createdAt DateTime @default(now()) @map("created_at")
  case      Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId, order]) // 游댠 Optimizar carga ordenada de im치genes
  @@map("case_images")
}

model Case {
  id         String   @id
  version    Int      @default(1) // Versionado del caso
  title      String
  area       String // 츼reas: "Embarazo y control prenatal", etc.
  difficulty Int // 1=Baja (6 MCQ), 2=Media (6 MCQ + 1 SHORT), 3=Alta (7 MCQ + 1 SHORT)
  dificultad String? // "Alta", "Media", "Baja" (texto legible)
  modulo     String? // Subm칩dulo espec칤fico (ej: "Hemorragia postparto")
  summary    String?
  isPublic   Boolean  @default(false)
  vignette   String?  @db.Text // Vi침eta cl칤nica completa (DEPRECATED - usar escenario)
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // Relaciones
  images            CaseImage[]
  questions         Question[]
  norms             MinsalNorm[]       @relation("CaseNorms")
  results           StudentResult[]
  favorites         Favorite[]
  pomodoroSessions  PomodoroSession[]
  engagementMetrics EngagementMetric[]

  @@index([area, difficulty])
  @@index([isPublic, createdAt(sort: Desc)])
  @@index([area, isPublic])
  @@index([modulo])
  @@index([version])
  @@map("cases")
}

model MinsalNorm {
  id    String @id
  name  String
  code  String @unique
  cases Case[] @relation("CaseNorms")

  @@map("minsal_norms")
}

model Option {
  id          String   @id
  text        String   @db.Text // Texto de la opci칩n (puede ser largo)
  isCorrect   Boolean  @default(false) @map("is_correct")
  explicacion String?  @db.Text // Explicaci칩n detallada de por qu칠 es correcta/incorrecta
  feedback    String?  @db.Text // Feedback adicional (legacy, mantener compatibilidad)
  order       Int      @default(0) // Orden de presentaci칩n (a, b, c, d)
  questionId  String   @map("question_id")
  question    Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId, order]) // 游댠 Optimizar carga ordenada de opciones
  @@map("options")
}

model QuestionImage {
  id         String   @id
  questionId String
  url        String
  alt        String
  caption    String?
  order      Int      @default(0)
  createdAt  DateTime @default(now()) @map("created_at")
  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)

  @@index([questionId, order]) // 游댠 Optimizar carga ordenada de im치genes
  @@map("question_images")
}

model Question {
  id              String  @id
  order           Int // Orden de la pregunta en el caso
  tipo            String  @default("mcq") // "mcq", "short", "multiselect", etc.
  enunciado       String  @db.Text // Texto de la pregunta
  text            String? @db.Text // Legacy field (mantener compatibilidad)
  caseId          String  @map("case_id")
  feedbackDocente String? @map("feedback_docente") @db.Text // Feedback pedag칩gico
  guia            String? @db.Text // Gu칤a para preguntas abiertas

  // Para preguntas tipo SHORT
  puntosMaximos Int?     @default(0) @map("puntos_maximos") // Puntaje m치ximo
  criteriosEval String[] @default([]) @map("criterios_evaluacion") // Keywords para evaluar

  options Option[]
  images  QuestionImage[]
  case    Case            @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseId, order]) // Optimizar carga ordenada de preguntas
  @@index([tipo]) // Filtrar por tipo de pregunta
  @@map("questions")
}

model StudentResult {
  id          String   @id
  userId      String
  caseId      String
  score       Int
  completedAt DateTime @default(now())
  mode        String?  @default("study")
  timeLimit   Int?
  timeSpent   Int?
  answers     Json?
  caseArea    String?
  caseTitle   String?
  totalPoints Int      @default(100)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  case        Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([caseArea])
  @@index([userId, completedAt(sort: Desc)])
  @@index([userId, caseArea]) // 游댠 Optimizar estad칤sticas por 치rea
  @@index([caseId]) // 游댠 Optimizar b칰squeda de resultados por caso
  @@map("student_results")
}

model User {
  id            String    @id
  email         String    @unique
  name          String?
  role          Role      @default(STUDENT)
  createdAt     DateTime  @default(now()) @map("created_at")
  updatedAt     DateTime  @updatedAt @map("updated_at")
  emailVerified DateTime? @map("email_verified")

  // Informaci칩n demogr치fica del estudiante
  country     String? // Pa칤s (ej: "Chile", "Argentina", "M칠xico")
  university  String? // Universidad (ej: "Universidad de Chile")
  yearOfStudy Int?    @map("year_of_study") // A침o de carrera (1-7)
  specialty   String? // Especialidad de inter칠s (opcional)
  bio         String? // Biograf칤a corta del estudiante
  avatar      String? // URL del avatar (desde Clerk o custom)

  results           StudentResult[]
  favorites         Favorite[]
  studySessions     StudySession[]
  pomodoroSessions  PomodoroSession[]
  engagementMetrics EngagementMetric[]

  // Relaciones de pagos y suscripciones
  subscriptions Subscription[]
  payments      Payment[]
  couponUsages  CouponUsage[]
  usageRecords  UsageRecord[]

  @@index([specialty]) // Optimizar b칰squedas por especialidad
  @@index([country]) // Optimizar an치lisis por pa칤s
  @@index([email]) // 游댠 Optimizar login (b칰squeda frecuente)
  @@index([createdAt(sort: Desc)]) // 游댠 Optimizar listado de usuarios nuevos
  @@map("users")
}

// Modelo para casos favoritos
model Favorite {
  id        String   @id @default(cuid())
  userId    String
  caseId    String
  createdAt DateTime @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@unique([userId, caseId]) // Un usuario no puede marcar el mismo caso dos veces
  @@index([userId])
  @@index([caseId, createdAt(sort: Desc)]) // 游댠 Optimizar trending cases
  @@map("favorites")
}

// Modelo para rastrear sesiones de estudio (para racha y tiempo)
model StudySession {
  id           String   @id @default(cuid())
  userId       String
  date         DateTime @default(now()) // Fecha de la sesi칩n
  casesStudied Int      @default(0) // Casos estudiados en esta sesi칩n
  timeSpent    Int      @default(0) // Tiempo en minutos

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, date(sort: Desc)])
  @@map("study_sessions")
}

// Modelo para sesiones Pomodoro (t칠cnica de productividad)
model PomodoroSession {
  id            String          @id @default(cuid())
  userId        String
  type          PomodoroType    @default(WORK)
  status        PomodoroStatus  @default(ACTIVE)
  duration      Int             @default(25) // Duraci칩n configurada en minutos
  timeRemaining Int // Tiempo restante en segundos
  timeSpent     Int             @default(0) // Tiempo real gastado en segundos
  completedAt   DateTime? // Fecha de completado
  caseId        String? // Caso asociado (opcional)
  caseTitle     String? // T칤tulo del caso para hist칩rico
  notes         String? // Notas de la sesi칩n
  createdAt     DateTime        @default(now()) @map("created_at")
  updatedAt     DateTime        @updatedAt @map("updated_at")

  user User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  case Case? @relation(fields: [caseId], references: [id], onDelete: SetNull)

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, status])
  @@index([caseId])
  @@map("pomodoro_sessions")
}

// Modelo para m칠tricas de engagement (recomendaciones, clics, tiempo)
model EngagementMetric {
  id                  String   @id @default(cuid())
  userId              String
  caseId              String
  source              String // 'recommendation', 'search', 'browse', 'trending', 'challenge'
  recommendationGroup String? // 'specialty', 'review', 'challenge', 'trending'
  action              String // 'view', 'click', 'complete', 'favorite'
  sessionDuration     Int? // Tiempo en segundos (si aplica)
  timestamp           DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  case Case @relation(fields: [caseId], references: [id], onDelete: Cascade)

  @@index([userId, timestamp(sort: Desc)])
  @@index([source])
  @@index([recommendationGroup])
  @@map("engagement_metrics")
}

enum Role {
  STUDENT
  EDITOR
  ADMIN
}

enum PomodoroType {
  WORK
  SHORT_BREAK
  LONG_BREAK
}

enum PomodoroStatus {
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

// ============================================================================
// SISTEMA DE SUSCRIPCIONES Y PAGOS (MERCADO PAGO)
// ============================================================================

// Plan de suscripci칩n (ej: Free, Basic, Premium, Enterprise)
model SubscriptionPlan {
  id            String        @id @default(cuid())
  name          String        @unique // "Free", "Basic", "Premium", "Enterprise"
  displayName   String // "Plan B치sico", "Plan Premium"
  description   String? // Descripci칩n del plan
  price         Decimal       @db.Decimal(10, 2) // Precio en CLP o USD
  currency      String        @default("CLP") // "CLP", "USD", "ARS", "MXN"
  billingPeriod BillingPeriod @default(MONTHLY) // MONTHLY, QUARTERLY, YEARLY
  trialDays     Int           @default(0) // D칤as de prueba gratis
  isActive      Boolean       @default(true) // Plan activo o descontinuado

  // L칤mites y caracter칤sticas del plan
  features           Json // { "casesPerMonth": 50, "aiEnabled": true, "customReports": false }
  maxCasesPerMonth   Int? // L칤mite de casos por mes (null = ilimitado)
  maxStudents        Int? // Para planes institucionales
  hasAI              Boolean @default(false) // Acceso a IA
  hasAdvancedStats   Boolean @default(false) // Estad칤sticas avanzadas
  hasPrioritySupport Boolean @default(false) // Soporte prioritario

  // Mercado Pago
  mpPreapprovalPlanId String? @unique @map("mp_preapproval_plan_id") // ID del plan en MP

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relaciones
  subscriptions Subscription[]

  @@index([isActive, price])
  @@map("subscription_plans")
}

// Suscripci칩n activa de un usuario
model Subscription {
  id     String @id @default(cuid())
  userId String
  planId String

  // Estado de la suscripci칩n
  status            SubscriptionStatus @default(ACTIVE)
  cancelAtPeriodEnd Boolean            @default(false) // Si se cancelar치 al final del per칤odo
  canceledAt        DateTime?          @map("canceled_at")
  cancelReason      String?            @map("cancel_reason")

  // Per칤odos de suscripci칩n
  currentPeriodStart DateTime  @map("current_period_start")
  currentPeriodEnd   DateTime  @map("current_period_end")
  trialStart         DateTime? @map("trial_start")
  trialEnd           DateTime? @map("trial_end")

  // Mercado Pago
  mpPreapprovalId   String?   @unique @map("mp_preapproval_id") // ID de suscripci칩n en MP
  mpPayerEmail      String?   @map("mp_payer_email")
  mpPayerId         String?   @map("mp_payer_id")
  mpStatus          String?   @map("mp_status") // Estado directo de MP
  mpLastPaymentDate DateTime? @map("mp_last_payment_date")

  // Metadata
  metadata Json? // Informaci칩n adicional

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relaciones
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan         SubscriptionPlan @relation(fields: [planId], references: [id])
  payments     Payment[]
  usageRecords UsageRecord[]

  @@index([userId, status])
  @@index([status, currentPeriodEnd])
  @@index([mpPreapprovalId])
  @@map("subscriptions")
}

// Registro de pagos (exitosos y fallidos)
model Payment {
  id             String  @id @default(cuid())
  subscriptionId String? // null si es pago 칰nico
  userId         String

  // Informaci칩n del pago
  amount        Decimal        @db.Decimal(10, 2)
  currency      String         @default("CLP")
  status        PaymentStatus  @default(PENDING)
  paymentMethod PaymentMethod?

  // Mercado Pago
  mpPaymentId         String? @unique @map("mp_payment_id") // ID del pago en MP
  mpPreferenceId      String? @unique @map("mp_preference_id") // ID de preferencia para links de pago
  mpMerchantOrderId   String? @map("mp_merchant_order_id")
  mpExternalReference String? @map("mp_external_reference") // Referencia interna
  mpStatus            String? @map("mp_status") // Estado directo de MP
  mpStatusDetail      String? @map("mp_status_detail")

  // Informaci칩n adicional
  description   String?
  failureReason String? @map("failure_reason")

  // Fechas importantes
  paidAt     DateTime? @map("paid_at")
  refundedAt DateTime? @map("refunded_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relaciones
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription  Subscription?  @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  webhookEvents WebhookEvent[]

  @@index([userId, status])
  @@index([status, createdAt(sort: Desc)])
  @@index([mpPaymentId])
  @@index([mpPreferenceId])
  @@map("payments")
}

// Cupones de descuento
model Coupon {
  id          String  @id @default(cuid())
  code        String  @unique // C칩digo del cup칩n (ej: "PROMO2025")
  name        String // Nombre descriptivo
  description String?

  // Tipo de descuento
  discountType  DiscountType // PERCENTAGE, FIXED_AMOUNT
  discountValue Decimal      @db.Decimal(10, 2) // 20 (para 20%) o 5000 (para $5000)
  currency      String?      @default("CLP") // Solo para FIXED_AMOUNT

  // Restricciones
  maxRedemptions    Int?     @map("max_redemptions") // Usos m치ximos totales
  redemptionsCount  Int      @default(0) @map("redemptions_count") // Usos actuales
  validFrom         DateTime @map("valid_from")
  validUntil        DateTime @map("valid_until")
  minPurchaseAmount Decimal? @map("min_purchase_amount") @db.Decimal(10, 2) // Compra m칤nima

  // Planes aplicables
  applicablePlans   String[] @map("applicable_plans") // IDs de planes o ["all"]
  firstPurchaseOnly Boolean  @default(false) @map("first_purchase_only")

  // Estado
  isActive Boolean @default(true) @map("is_active")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relaciones
  usageRecords CouponUsage[]

  @@index([code, isActive])
  @@index([validFrom, validUntil])
  @@map("coupons")
}

// Registro de uso de cupones
model CouponUsage {
  id             String  @id @default(cuid())
  couponId       String
  userId         String
  subscriptionId String?

  // Informaci칩n del descuento aplicado
  discountAmount Decimal @map("discount_amount") @db.Decimal(10, 2)
  originalAmount Decimal @map("original_amount") @db.Decimal(10, 2)
  finalAmount    Decimal @map("final_amount") @db.Decimal(10, 2)

  // Timestamps
  usedAt DateTime @default(now()) @map("used_at")

  // Relaciones
  coupon Coupon @relation(fields: [couponId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([couponId, usedAt(sort: Desc)])
  @@map("coupon_usage")
}

// Registro de uso del servicio (para l칤mites de plan)
model UsageRecord {
  id             String  @id @default(cuid())
  userId         String
  subscriptionId String?

  // Tipo de uso
  resourceType UsageResourceType // CASE_COMPLETION, AI_REQUEST, EXPORT_REPORT
  quantity     Int               @default(1)

  // Per칤odo de facturaci칩n
  billingPeriodStart DateTime @map("billing_period_start")
  billingPeriodEnd   DateTime @map("billing_period_end")

  // Metadata
  metadata Json? // Informaci칩n adicional del uso

  // Timestamps
  recordedAt DateTime @default(now()) @map("recorded_at")

  // Relaciones
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription Subscription? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@index([userId, billingPeriodStart, resourceType])
  @@index([subscriptionId, resourceType])
  @@map("usage_records")
}

// Webhooks de Mercado Pago (auditor칤a completa)
model WebhookEvent {
  id String @id @default(cuid())

  // Informaci칩n del evento
  eventType String @map("event_type") // "payment", "subscription", etc.
  action    String // "created", "updated", "payment.created", etc.

  // Mercado Pago IDs
  mpId     String? @map("mp_id") // ID del recurso en MP
  mpUserId String? @map("mp_user_id")

  // Payload completo
  payload Json // Payload completo del webhook

  // Procesamiento
  processed       Boolean   @default(false)
  processedAt     DateTime? @map("processed_at")
  processingError String?   @map("processing_error")
  retryCount      Int       @default(0) @map("retry_count")

  // Relaciones opcionales
  paymentId String?
  payment   Payment? @relation(fields: [paymentId], references: [id], onDelete: SetNull)

  // Timestamps
  receivedAt DateTime @default(now()) @map("received_at")

  @@index([eventType, action])
  @@index([processed, receivedAt(sort: Asc)])
  @@index([mpId])
  @@map("webhook_events")
}

// ============================================================================
// ENUMS PARA EL SISTEMA DE PAGOS
// ============================================================================

enum BillingPeriod {
  MONTHLY
  QUARTERLY
  BIANNUAL
  YEARLY
}

enum SubscriptionStatus {
  ACTIVE // Suscripci칩n activa
  TRIALING // En per칤odo de prueba
  PAST_DUE // Pago vencido
  CANCELED // Cancelada por el usuario
  EXPIRED // Expirada (fin de per칤odo sin renovaci칩n)
  SUSPENDED // Suspendida por admin
  PAUSED // Pausada temporalmente
}

enum PaymentStatus {
  PENDING // Pendiente de pago
  PROCESSING // Procesando
  APPROVED // Aprobado
  AUTHORIZED // Autorizado (para captura posterior)
  IN_MEDIATION // En mediaci칩n
  REJECTED // Rechazado
  CANCELLED // Cancelado
  REFUNDED // Reembolsado
  CHARGED_BACK // Contracargo
}

enum PaymentMethod {
  CREDIT_CARD
  DEBIT_CARD
  BANK_TRANSFER
  CASH // Efectivo (PagoFacil, Rapipago, etc.)
  DIGITAL_WALLET // Mercado Pago, etc.
  OTHER
}

enum DiscountType {
  PERCENTAGE // Descuento porcentual (ej: 20%)
  FIXED_AMOUNT // Monto fijo (ej: $5000)
}

enum UsageResourceType {
  CASE_COMPLETION // Caso cl칤nico completado
  AI_REQUEST // Solicitud de IA
  EXPORT_REPORT // Exportaci칩n de reporte
  CUSTOM_CASE // Caso personalizado creado
}

// ============================================================================
// MODELO PARA ESTAD칈STICAS DE JUEGOS
// ============================================================================

model GameStats {
  id            String   @id @default(cuid())
  userId        String   @map("user_id")
  gameType      String   @map("game_type") // "wordsearch" | "hangman"
  totalScore    Int      @default(0) @map("total_score")
  gamesPlayed   Int      @default(0) @map("games_played")
  gamesWon      Int      @default(0) @map("games_won")
  bestStreak    Int      @default(0) @map("best_streak")
  currentStreak Int      @default(0) @map("current_streak")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  @@unique([userId, gameType])
  @@index([userId])
  @@index([gameType])
  @@map("game_stats")
}
