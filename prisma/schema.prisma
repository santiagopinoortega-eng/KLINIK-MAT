generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model CaseImage {
  id         String   @id
  caseId     String
  url        String
  alt        String
  caption    String?
  order      Int      @default(0)
  createdAt  DateTime @default(now()) @map("created_at")
  case       Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  
  @@map("case_images")
}

model Case {
  id                String         @id
  title             String
  area              String
  difficulty        Int
  summary           String?
  isPublic          Boolean        @default(false)
  vignette          String?
  createdAt         DateTime       @default(now()) @map("created_at")
  updatedAt         DateTime       @map("updated_at")
  dificultad        String?
  feedbackDinamico  Json?          @map("feedback_dinamico")
  modulo            String?
  images            CaseImage[]
  questions         Question[]
  norms             MinsalNorm[]   @relation("CaseNorms")
  results           StudentResult[]
  favorites         Favorite[]
  engagementMetrics EngagementMetric[]
  
  @@map("cases")
  @@index([area, difficulty]) // Optimizar búsquedas por área y dificultad
  @@index([isPublic, createdAt(sort: Desc)]) // Optimizar lista de casos públicos
  @@index([area, isPublic]) // Optimizar filtrado de casos por área
}

model MinsalNorm {
  id    String  @id
  name  String
  code  String  @unique
  cases Case[]  @relation("CaseNorms")
  
  @@map("minsal_norms")
}

model Option {
  id         String    @id
  text       String
  isCorrect  Boolean   @default(false)
  feedback   String?
  questionId String
  question   Question  @relation(fields: [questionId], references: [id])
  
  @@map("options")
}

model QuestionImage {
  id         String    @id
  questionId String
  url        String
  alt        String
  caption    String?
  order      Int       @default(0)
  createdAt  DateTime  @default(now()) @map("created_at")
  question   Question  @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  @@map("question_images")
}

model Question {
  id              String            @id
  order           Int
  text            String
  caseId          String
  feedbackDocente String?
  guia            String?
  options         Option[]
  images          QuestionImage[]
  case            Case              @relation(fields: [caseId], references: [id])
  
  @@map("questions")
}

model StudentResult {
  id          String   @id
  userId      String
  caseId      String
  score       Int
  completedAt DateTime @default(now())
  mode        String?  @default("study")
  timeLimit   Int?
  timeSpent   Int?
  answers     Json?
  caseArea    String?
  caseTitle   String?
  totalPoints Int      @default(100)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  case        Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  
  @@map("student_results")
  @@index([caseArea])
  @@index([userId, completedAt(sort: Desc)])
}

model User {
  id              String            @id
  email           String            @unique
  name            String?
  role            Role              @default(STUDENT)
  createdAt       DateTime          @default(now()) @map("created_at")
  updatedAt       DateTime          @updatedAt @map("updated_at")
  emailVerified   DateTime?         @map("email_verified")
  
  // Información demográfica del estudiante
  country         String?           // País (ej: "Chile", "Argentina", "México")
  university      String?           // Universidad (ej: "Universidad de Chile")
  yearOfStudy     Int?              @map("year_of_study") // Año de carrera (1-7)
  specialty       String?           // Especialidad de interés (opcional)
  bio             String?           // Biografía corta del estudiante
  avatar          String?           // URL del avatar (desde Clerk o custom)
  
  results         StudentResult[]
  favorites       Favorite[]
  studySessions   StudySession[]
  engagementMetrics EngagementMetric[]
  
  @@map("users")
  @@index([specialty]) // Optimizar búsquedas por especialidad
  @@index([country]) // Optimizar análisis por país
}

// Modelo para casos favoritos
model Favorite {
  id         String   @id @default(cuid())
  userId     String
  caseId     String
  createdAt  DateTime @default(now()) @map("created_at")
  
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  case       Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  
  @@unique([userId, caseId]) // Un usuario no puede marcar el mismo caso dos veces
  @@map("favorites")
  @@index([userId])
}

// Modelo para rastrear sesiones de estudio (para racha y tiempo)
model StudySession {
  id           String   @id @default(cuid())
  userId       String
  date         DateTime @default(now()) // Fecha de la sesión
  casesStudied Int      @default(0) // Casos estudiados en esta sesión
  timeSpent    Int      @default(0) // Tiempo en minutos
  
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@map("study_sessions")
  @@index([userId, date(sort: Desc)])
}

// Modelo para métricas de engagement (recomendaciones, clics, tiempo)
model EngagementMetric {
  id                   String   @id @default(cuid())
  userId               String
  caseId               String
  source               String   // 'recommendation', 'search', 'browse', 'trending', 'challenge'
  recommendationGroup  String?  // 'specialty', 'review', 'challenge', 'trending'
  action               String   // 'view', 'click', 'complete', 'favorite'
  sessionDuration      Int?     // Tiempo en segundos (si aplica)
  timestamp            DateTime @default(now())
  
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  case                 Case     @relation(fields: [caseId], references: [id], onDelete: Cascade)
  
  @@map("engagement_metrics")
  @@index([userId, timestamp(sort: Desc)])
  @@index([source])
  @@index([recommendationGroup])
}

enum Role {
  STUDENT
  EDITOR
  ADMIN
}

